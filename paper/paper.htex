\documentclass[10pt,conference]{IEEEtran}
%\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amssymb,amsfonts}
%amsmath,
\usepackage{mathtools}

\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{bussproofs}

\usepackage{pgf}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\usepackage{etoolbox}
\usepackage{holtexbasic,url,amsmath,environ}
\renewcommand{\HOLTokenTurnstile}{\ensuremath{\vdash\!\!}}
\renewcommand{\HOLinline}[1]{\ensuremath{#1}}
\renewcommand{\HOLKeyword}[1]{\mathsf{#1}}
\renewcommand{\HOLConst}[1]{{\textsf{\upshape #1}}}
\renewcommand{\HOLTyOp}[1]{\textsf{\itshape #1}}
\renewcommand{\HOLSymConst}[1]{\HOLConst{#1}}
\renewcommand{\HOLTokenBar}{\ensuremath{\mathtt{|}}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{conjecture}{Desideratum}
\ifdef{\dpspecial}{
%% tmp by Dirk
\newcommand{\HOLtm}[1]{\texttt{#1}}
\newcommand{\HOLty}[1]{\texttt{#1}}
\newcommand{\HOLthm}[2][]{\texttt{#2}}
\newcommand{\n}{\\n}
}{}
\NewEnviron{holthmenv}{\[\begin{array}[t]{l}\BODY\end{array}\]\ignorespacesafterend}
\newcommand{\TODO}[1]{{\bf TODO:} #1}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Modular Synthesis of Verified Verifiers of Computation with STV Algorithms}
%*\\
%{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
%should not be used}
%\thanks{Identify applicable funding agency here. If none, delete this.}


\author{\IEEEauthorblockN{Milad K. Ghale}
\IEEEauthorblockA{\textit{The Australian National University} \\
%\textit{name of organization (of Aff.)}\\
Canberra, Australia \\
milad.ketabghale@anu.edu.au}
\and
\IEEEauthorblockN{Dirk Pattinson}
\IEEEauthorblockA{\textit{The Australian National University} \\
%\textit{name of organization (of Aff.)}\\
Canberra, Australia \\
dirk.pattinson@anu.edu.au}
\and
\IEEEauthorblockN{Michael Norrish}
\IEEEauthorblockA{\textit{Data61, CSIRO, and ANU} \\
%\textit{Data61, CSIRO, and ANU}\\
Canberra, Australia \\
Michael.Norrish@data61.csiro.au}
%\and
%\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
%\and
%\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
%\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
%\textit{name of organization (of Aff.)}\\
%City, Country \\
%email address}
}

\maketitle
\begin{abstract}
\end{abstract}

\begin{IEEEkeywords}

\end{IEEEkeywords}
\section{Introduction}\label{sec:intro}
%\setlength{\abovedisplayskip}{0.5em}
%\setlength{\belowdisplayskip}{0.5em}
\section{Evidences}
\label{sec:DataEv}
  
We are motivated to 
%engineer a trustworthy practical  framework to answer the 
tackle the following problem. How can one verify that any execution of any implementation $\mathcal{P}$ whose source code is secret of an arbitrary  known STV algorithm $\mathcal{A}$ correctly computes the end result according to  $\mathcal{A}$?  



To begin 
%with addressing the problem, 
assume $\mathcal{P}$ is an implementation of an algorithm $\mathcal{A}$. We reasonably demand each execution of $\mathcal{P}$ on a given input $x$ consisting of ballots recorded in the election to output the winners $y$ and evidence $\omega$ as claim  for correctness of the execution.  
 Having evidence available for each execution of $\mathcal{P}$ facilitates checking correctness of the computation carried out \emph{independently} of the (source code of) $\mathcal{P}$. Therefore the original problem boils down to how one can verify the evidence of any \emph{instance of computation} with any algorithm $\mathcal{A}$.


  
The evidence as such must be enough informative to provide transparency of tallying and also allow  voters, or at least a large pool of scrutineers, to verify for themselves that the tally is authentically processed as per instructions of the counting scheme  so that winners truly reflect will of the voters.    
Therefore the questions becomes what information is enough  
for establishing transparency and verifiability of tallying  and what data structure for recording the information in evidence we should choose.
\subsection{Characterisation of Evidence} 
A comprehensive analysis of different STV algorithms reveals existence of a common underlying abstract data type among STV algorithms as follows. 
%Each STV scheme operates on the following data.
\begin{itemize}
\item Some ballots to deal with (assuming) recorded as cast by voters. Each ballot is a pair consisting of a list expressing the preference of a voter and a fractional transfer value,
\item a quota which is the least amount of votes needed to attract in order to be elected, 
\item some candidates competing in the election, 
\item some number of vacancies for which candidates compete,
\item \emph{discrete states of computation} which encapsulate necessary  pieces of information needed to transparently know how the tallying has progressed from the beginning to the end and to be able to independently verify its correctness provided access to the information is granted. 
\end{itemize}
There are two kinds of discrete states of computation. Some of them are final states where tallying has reached a halting state by finding the winners of the election. The other consist of non-final ones where bits and pieces of data are manipulated according to counting mechanism of the STV scheme used, to eventually obtain an end result. Each non-final state comprises seven pieces of data: 
\begin{itemize}
 \item\textbf{uncounted ballots} which await being counted,
 \item\textbf{tally} for holding information about the amount of votes that each candidate has hitherto attracted %up to this state of computation,
 \item\textbf{pile} to know the ballots allocated to each candidate, 
 \item\textbf{backlog of elected} candidates who have exceeded the quota and their surplus votes awaits being transferred,
 \item\textbf{backlog of eliminated} ones whose votes awaits transfer,
 \item\textbf{elected candidates} who are the already elected ones whose surplus votes must be transferred,
 \item\textbf{continuing candidates} still continuing in the election. 
 \end{itemize}
The non-final and final states specified above provide us with all information one needs. We therefore find a perfect characterisation for evidence. 
\begin{definition}\label{formalEv}
Suppose an STV algorithm $\mathcal{A}$ is given and $Q$, $s$ and $C$ are respectively the quota, number of vacancies and competing candidates in an electon whose counting algorithm is $\mathcal{A}$ . Also assume  $y$ is the output of an execution of $\mathcal{A}$ on an input $x$. By evidence $\hat{\omega}$ for the execution  we mean the quadruple $(Q,s,C,\Omega)$, where $\Omega$ is the chronological sequence of all states of this instance of computation visited from the initial state where $x$ is input to the final state where $y$ is output.   
\end{definition}
\section{The Generic STV  Machine}
\label{sec:Machine}
\setlength{\abovedisplayskip}{0.5em}
\setlength{\belowdisplayskip}{0.5em}
We have already discussed an abstract data type whose values  formally represent evidence. However we do not yet possess an operational semantics for manipulating data to validate evidence.   On one hand, the semantics must be flexible enough to accommodate variations existing in the counting mechanism of STV algorithms so that we can produce verifiers  specifically operating for validation of evidence output by their associated scheme. On the other hand it must facilitate designing and developing the framework modularly while offering automation of synthesising process of verifiers.


In a secondary examination of the STV family, we also identify a general algorithmic mechanism for performing computation on evidence, which realises the \emph{commonalities} among the family members. This generic method comprises seven general actions~(Figure~\ref{GenSteps}) corresponding to actions that tally officers take when counting votes.
\begin{figure} 
 \begin{itemize}
\item\textbf{count} for counting the uncounted ballots,
\item\textbf{elect} for electing all or some of the electable candidates, 
\item\textbf{transfer-elected} for distributing surplus votes of elected, %candidates, 
\item\textbf{eliminate} to exclude one or some candidates, 
\item\textbf{transfer-removed} to distribute votes of   the eliminated, %candidates, 
\item\textbf{elected-win} for terminating tallying whenever the vacancies are filled or there is no continuing candidate left, 
\item\textbf{hopeful-win} for terminating tallying whenever  the number of already elected and continuing candidates collectively does not exceed the initial vacancies. 
\end{itemize}
\caption{Generic STV Counting Steps}
\label{GenSteps}
\end{figure}
Each action is constituted of  pre-conditions on when and how the action comes into effect, and post-conditions dictating what effect applying the action brings about by describing the new state to which computation proceeds. In fact, these conditions are the formal counterparts of the legal clauses in the textual specification of the counting scheme which tell tally officers how to proceed with tallying, and they are common between all flavours of STV. 

For example a constant pre-condition for applying elimination  asserts that there must be no uncounted ballot left and another one declares that no candidate should be electable at the current state of counting. A post-condition of elimination is that once a candidate is excluded from counting, the list of continuing candidates is updated accordingly so that the excluded candidate no longer received votes. Conjunctions of such declarations comprise what an action is and what an application of that action means.


The underlying abstract data type and the universal algorithmic pattern found in STV characterise components of a finite state machine which we call \emph{generic STV}~(Definition\ref{STVMachine}). The set of machine states consist of the discrete states of computation $\mathcal{S}$ mentioned earlier. The seven generic actions form the transition labels $\mathcal{T}$ of the machine. Last, the everywhere present pre- and post-conditions which define (content of)  the actions, make a small-step operational semantics for the machine.  
Note that the states of computation recorded in all possible  evidence now become identical with machine states.


\begin{definition}[The generic STV machine]\label{STVMachine}
Let $\mathcal{S}$  and $\mathcal{T}$
be respectively the set of machine states and transition labels.  Also assume for $t\in\mathcal{T}$, $S_{t}$ $=$ $\bigwedge_{\atop{i\leq j_{t}}} \psi_{i}$ where  $\psi_{i}$ is the formal specification (in higher-order logic) of a pre- or post-condition of $t$. Then \emph{generic STV} is the triple $M = \langle \mathcal{S}, \mathcal{T}, (S_t)_{t \in \mathcal{T}} \rangle$.  
\end{definition}
There are nonetheless variations in STV algorithms  which we  recognise  by separate \emph{instantiations} into the machine.  
\subsection{Instantiations of the Machine with Specific STV schemes}
Differences exist between counting algorithms of STV schemes.  
 For example in the STV used for electing the upper house representatives of the Victoria state of Australia (Victoria STV), distributing votes of an eliminated candidate occurs step by step in order of the magnitude of the fractional values that those votes carry.  Consequently, a pre-condition for applying the action is to first assure that upon each instance of applying transfer-removed action (a) exactly those votes which have the same fractional value are transferred and (b) the transfer happens according to the magnitude order. In contrast, for example, the STV used in the lower house elections of Tasmania state of Australia (Tasmania STV) does not have such pre-condition simply because votes of an eliminated candidate are transferred in a single application of transfer-removed. There are also variations in post-conditions. For example transfer-elect of the ACT STV used in the lower house elections of the ACT state of Australia requires distributing only the last parcel of surplus votes received by an elected candidate. But Victoria STV specifies transferring all surplus votes of an elected candidate.  


We formally realise variations of STV algorithms by instantiation~(Definition\ref{STVInst}) of the generic machine. Recall that the semantics of the machine is formed by conjunctions of formally specified universally appearing pre and post-conditions in STV algorithms. An instantiation of the machine with an STV algorithm $\mathcal{A}$ happens by enriching the generic semantics by adding formal specifications of the legal clauses that are specific to $\mathcal{A}$. We hence come to define an operational semantics functioning in accordance with instructions of $\mathcal{A}$. 
\begin{definition}[Instantiation of the Machine]\label{STVInst}
Assume the generic machine $M = \langle \mathcal{S}, \mathcal{T}, (S_t)_{t \in \mathcal{T}} \rangle$ as in Definition~\ref{STVMachine}. An instantiation $\hat{\mathcal{A}}$ for an STV algorithm $\mathcal{A}$ into the generic STV machine $M$ is a triple $\langle \mathcal{S}, \mathcal{T}, (S'_t)_{t \in \mathcal{T}} \rangle$, where for each $t\in\mathcal{T}$, $S'_{t}$ $=$ $S_{t}\wedge\bigwedge_{\atop{i\leq j'_{t}}} \phi_{i}$. Each $\phi_{i}$ is the formal specification of a pre- or post-condition specific to $\mathcal{A}$.   
\end{definition}

The operational semantics of each instantiation allows  to perform operations such as validation on evidence. Definition~\ref{verifier} lays down what verifying an evidence amount to. Informally speaking, to check if  evidence is valid one simply needs to inspect if transitions  between each two consecutive states of computation appearing in the evidence occur by a legitimate application of a counting action of the scheme used.

\begin{definition}[verifier]\label{verifier}
Assume $\hat{\mathcal{A}}= \langle \mathcal{S}, \mathcal{T}, (S'_t)_{t \in \mathcal{T}} \rangle$ is an instantiation of the STV algorithm $\mathcal{A}$. A verifier for instances of computation with $\mathcal{A}$ is a function $\hat{\mathcal{V}}$ mapping from $\mathbb{Q}\times\mathbb{N}\times 2^{C}\times$ \textsf{List}$(\mathcal{S})$ to $\{0,1\}$ such that for any evidence $\hat{\omega} = (Q,s,C,\Omega)$ where $\Omega=\langle\Omega_{1},\dots,\Omega_{n}\rangle$, $\hat{\mathcal{V}}(\hat{\omega}) = 1$ if and only if the following holds:\\
$\forall i\in\{1,\dots,n-1\}.$ 
%\hspace*{0.2cm}$\forall \Omega_{i-1}$ $\Omega_{i}\in\mathcal{S}.$
%$\exists \Omega_{1}$ $\Omega_{2}\in$ \textsf{List} $(\mathcal{S}).$ $\Omega = \Omega_{1} + [\Omega_{i-1};\Omega_{i}] + \Omega_{2}$  
$\exists t\in\mathcal{T}.$  $(\Omega_{i-1},\Omega_{i})\in t$ $\wedge~\vdash\mathcal{S}'_{t}[\Omega_{i-1},\Omega_{i}]$\\ 
where $\mathbb{Q}$ and $\mathbb{N}$ respectively represent the set of rational and natural numbers, $2^{C}$ is the set of all subsets of $C$, and \textsf{List}$(S)$ is the set of all possible lists of machine states. $\Omega_{i-1}$ is a pre-state and $\Omega_{i}$ is a post-state visited in the execution. The last line means that pre- and post-conditions  of applying $t$ to move from $\Omega_{i-1}$ to $\Omega_{i}$  are logically true. 
\end{definition} 
We shall next provide an example to concretely illustrate a piece of evidence and exemplify how STV schemes work. 
 \subsection{An Example of a Concrete Piece of Evidence}
\label{subsec:InstEv}
Figure~\ref{EvInst} depicts evidence of a small election whose counting algorithm is the ACT STV 
with three candidates $a$, $b$ and $c$, and initially recorded ballots containing
$b_1=([a,c],1/1)$, $b_2=([a,b,c],1/1)$, $b_3=([a,c,b],1/1)$,
$b_4=([b,a],1/1)$, $b_5=([c,b,a],1/1)$.  The first component of each ballot is a preference-ordered list of candidates, and the second is the fractional transfer value (initially set to $1/1$). The evidence consists of a \emph{header} that specifies the quota (computed according to the ACT STV instructions), the number of vacancies, and the list of competing candidates. 
The fourth line is the election result, and the remainder of the evidence are non-final states visited to compute this
outcome. Each non-final state shows uncounted ballots, tallies of candidates, piles of votes attracted, backlog of the elected, backlog of the eliminated, list of elected candidates, and list of continuing candidates. 

First preferences for each candidate are computed, and ballots counted in favour of particular candidates are placed onto that candidate’s pile. Here, $a$ is the first preference on $b_{1}$, $b_{2}$, and $b_{3}$, and $b$ receives $b_{4}$, and $c$ receives $b_{5}$ . Tallies are updated so that tally of $a$ becomes 3, and $b$
and $c$ each reach $1/1$. As $a$ exceeds the quota, he is elected and the fractional value of his surplus is updated according to the ACT scheme. Then $a$'s surplus is transferred to continuing candidates $b$ and $c$ and votes are counted according to next preferences shown on $a$'s surplus votes. Candidate $b$ and $c$ each attracts one vote. However  neither of them reaches to the quota. Therefore the weakest one $b$ is eliminated. As the number of elected and continuing candidates does not exceed the initial vacancies, the election terminates by declaring $a$ and $c$ winners.
\begin{small} 
\begin{figure}[b]
\begin{tabular}{c@{\hspace{2cm}}c} 
\AxiomC{\tiny 8/3} \noLine

\UnaryInfC{\tiny 2} \noLine \UnaryInfC{\tiny $[a,b,c]$} \noLine

\UnaryInfC{\scriptsize [a,c]} \LeftLabel{\tiny hwin}

\UnaryInfC{\tiny [$b_4$,([a,b,c],1/9)]]; a\{3/1\} b\{10/9\} c\{11/9\}; a\{[]\} b\{[]\}
c\{[[$b_{5}$,([c],1/9),([c,b],1/9),([c],1/9)]]\}; []; [a]; [c]}

\LeftLabel{\tiny elim} \UnaryInfC{\tiny []; a\{3/1\} b\{10/9\}
c\{11/9\}, a\{[]\} b\{[[$b_4$],[([a,b,c],1/9)]]\}
c\{[[$b_5$],[([a,c],1/9),([a,c,b],1/9)]]\}; []; [a]; [b,c]}

\LeftLabel{\tiny count} \UnaryInfC{\tiny
[([a,c],1/9),([a,b,c],1/9),([a,c,b],1/9)]; a\{3/1\}
b\{1/1\} c\{1/1\}; a\{[]\} b\{[[$b_4$]]\} c\{[[$b_5$]]\}; []; [a]; [b,c]}

\LeftLabel{\tiny tr-elect} \UnaryInfC{\tiny []; a\{3/1\} b\{1/1\}
 c\{1/1\}; a\{[[([a,c],1/9),([a,b,c],1/9),([a,c,b],1/9)]]\}
b\{[[$b_4$]]\} c\{[[$b_5$]]\}; [a]; [a]; [b,c]} \LeftLabel{\tiny elect}

\UnaryInfC{\tiny []; a\{3/1\} b\{1/1\} c\{1/1\}; a\{[[$b_1$,$b_2$,$b_3$]]\}
b\{[[$b_4$]]\} c\{[[$b_5$]]\}; []; []; [a,b,c]} \LeftLabel{\tiny count}

\UnaryInfC{\tiny ba; a\{0/1\} b\{0/1\} c\{0/1\}; a[] b[] c[]; []; [];
[a,b,c]} \DisplayProof \end{tabular} \caption{An example of  Evidence} \label{EvInst} \end{figure} \end{small}

\section{The Framework Architecture}\label{sec:Arc} 
We progress through three macro-level phases to develop the framework. For the first phase we use HOL4 to formally specify, implement and verify the generic STV, its instantiations, verifiers, and every auxiliary assertions needed for these ends. The second step relies on the verified proof translation tool of CakeML to provably correctly translate implementations of the first phase into equivalent CakeML implementations. The last phase uses the ecosystem of CakeML and its verified compiler to generate machine executable evidence verifiers.   


Figure~\ref{PicArc} is a simplified schematic illustration of the framework modules and their dependencies. We explain the purpose of each and then describe how they collectively function.

\paragraph*{\textbf{Auxiliary}} The module contains specification, implementation and verification of the generic STV. It consists of subdivisions for formal specification of the machine and its components, implementation of functions  meant to be the computational counterparts of the specifications and verification of the implementations by proving that they logically satisfy their respective specifications. Moreover we include specification, implementation and verification of helper assertions which appear in many well-known STV schemes here so that Auxiliary also serves as a comprehensive library for STV. 
\paragraph*{\textbf{Instantiations}}
  Instantiations of the generic STV happen in separate modules which we have schematically shown only two, namely   \textbf{STV}$_{1}$ and \textbf{STV}$_{2}$. An instantiation module \textbf{STV}$_{i}$ for an algorithm $\mathcal{A}$ consists of a subdivision for specification $\hat{\mathcal{A}}_{spec}$ of  the scheme and another one its implementation $\hat{\mathcal{A}}_{dec}$. 
\paragraph*{\textbf{Proofs}} We prove that for an algorithm $\mathcal{A}$ in the above modules,  $\hat{\mathcal{A}}_{dec}$ is logically equivalent to $\hat{\mathcal{A}}_{spec}$. We automate proofs so that they work for various instantiations. 
\paragraph*{\textbf{Verifier}} This module formally realises  the notion of verifier in Definition~\ref{verifier}. However, it is developed in a way that automatically operates  regardless of which STV algorithm is instantiated into the machine. It has three subdivisions. A  specification $\hat{\mathcal{V}}_{spec}$ defining what a verifier is, the implementation $\hat{\mathcal{V}}_{dec}$ and proofs of equivalence of $\hat{\mathcal{V}}_{spec}$ and $\hat{\mathcal{V}}_{dec}$.
\paragraph*{\textbf{Translation}} We translate each implementation $\hat{f}_{imp}$ in HOL4 to a proven  equivalent implementation $f_{\tau}$ in CakeML's environment by using the verified proof translator of CakeML. For example, an implementation  $\hat{\mathcal{A}}_{imp}$ of a scheme $\mathcal{A}$ and its   verifier $\hat{\mathcal{V}}_{imp}$ are  respectively translated into $\mathcal{A}_{\tau}$  and $\mathcal{V}_{\tau}$. 
\paragraph*{\textbf{DeepSpec}} 
For any translated verifier $\mathcal{V}_{\tau}$ and the translated evidence parser $\mathcal{P}_{\tau}$, we obtain logically equivalent deep CakeML embeddings  $\mathcal{V}^{*}$ and $\mathcal{P}^{*}$, respectively. We then use them to establish end-to-end desired properties, based on CakeML's I/O model, about the interaction of the executable verifier with its hosting operating system.   
\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, 
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}
\begin{figure}[t]
\centering
%\framebox[\columnwidth]{
\begin{tikzpicture}[->,>=stealth']

 % Position of PARAM 
 % Use previously defined 'state' as layout (see above)
 % use tabular for content to get columns/rows
 % parbox to limit width of the listing
 \node[state] (Aux) 
 {\begin{tabular}{l}
  \textbf{Auxiliary}
 \end{tabular}};
 
  % STATE STVONE
 \node[state,
  below of=Aux,
  %yshift = -2cm,
  node distance=1.1cm,
  anchor=center] (proof) 
 {%
 \begin{tabular}{l}
  \textbf{Proofs}
 \end{tabular}
 }; 
  
   % STATE PARAM
 \node[state,
  left of= proof,
  xshift = -1.3cm,
  %node distance=1.5cm,
  anchor=center] (STV1) 
 {%
 \begin{tabular}{l}
  \textbf{STV$_{1}$}
 \end{tabular}
 }; 
 
  % STATE STVTWO
 \node[state,
  right of= proof,
  xshift = 1.2cm,
  %node distance=1.5cm,
  anchor=center] (STV2) 
 {%
 \begin{tabular}{l}
  \textbf{STV$_{2}$}
 \end{tabular}
 };
   % STATE EXETWO
 \node[state,
  below of= STV2,
  xshift = 1cm,
  node distance=1.2cm,
  anchor=center] (V) 
 {%
 \begin{tabular}{l}
  \textbf{Verifier}
 \end{tabular}
 };  

   \node[state,
  below of= STV1,
  xshift = - 1cm,
  node distance=1.2cm,
  anchor=center] (T) 
 {%
 \begin{tabular}{l}
  \textbf{Tran}
 \end{tabular}
 };  
 
 \node[state,
  below of = proof,
   %xshift = 3cm,
   node distance = 1cm,
  anchor=center
  %text width=2.5cm
  ] (Deep) 
 {%
 \begin{tabular}{l}
  \textbf{DeepSpec}
%  \parbox{1.7cm}{}
 \end{tabular}
 };
 
  \node[state,
  below of = Deep,
   %xshift = 3cm,
   node distance = 1.1cm,
  anchor=center
  %text width=2.5cm
  ] (parser) 
 {%
 \begin{tabular}{l}
  \textbf{Parser}
%  \parbox{1cm}{}
 \end{tabular}
 };

 \node[state,
  below of = parser,
   %xshift = 3cm,
   node distance = 1.1cm,
  anchor=center] (comp)
  %text width=2.5cm
   {%
 \begin{tabular}{l}
  \textbf{Compilation}
  %\parbox{2cm}{}
 \end{tabular}
 };
 
  \node[state,
  left of = parser,
   xshift = -2cm,
  % node distance = 1.7cm,
  anchor=center
  %text width=2.5cm
  ] (Exe1) 
 {%
 \begin{tabular}{l}
  \textbf{Executable$_{1}$}
  %\parbox{2.5cm}{}
 \end{tabular}
 };
 
 \node[state,
  right of = parser,
   xshift = 2cm,
  % node distance = 1.7cm,
  anchor=center
  %text width=2.5cm
  ] (Exe2) 
 {%
 \begin{tabular}{l}
  \textbf{Executable$_{2}$}
  %\parbox{2cm}{}
 \end{tabular}
 };

 % draw the paths and and print some Text below/above the graph 
 

 \path (proof)     edge (Aux)
       (STV1)     edge (Aux)
       (STV2) edge (Aux)
       (proof) edge (STV1)
       (proof) edge (STV2)
       (V) edge (proof)
       (Deep) edge (V)
       (T) edge (parser)
       (comp) edge [bend left = 60] node[anchor=north,above]{} (Deep)
       (comp) edge [bend right= 60] node[anchor=north,above]{} (Deep)
      (Exe1) edge  (comp) 
      (Exe2) edge (comp)
       (T) edge (proof)
       (Deep) edge (T)
       (parser) edge [bend left = 60] node[anchor=north,above]{} (Aux)
       (parser) edge [bend right= 60] node[anchor=north,above]{} (Aux);
       
\end{tikzpicture}
\caption{Architecture of the Framework, note that direction of arrow represents module dependencies}
\label{PicArc}
\end{figure}
\paragraph*{\textbf{Compilation}} 
Instantiations of CakeML's  compiler for generating machine executable verifiers happen in this module. For any deeply embedded $\mathcal{V}^{*}_{i}$, corresponding to $\hat{\mathcal{V}}_{dec}$ in \textbf{STV}$_{i}$, using proofs  established in \textbf{DeepSpec}, we instantiate the compiler to synthesise executable  verifier $\mathcal{V}_{i}$.  
\section{The Generic STV Formalised}\label{sec:GenCertVer}
We proceed through three steps, namely specification, implementation and verification of implementations in HOL4 to formally verify the machine and its components.
\paragraph*{Specification}  
Recall that we require minimising the trusted computing base  for computing with generated verifiers. The specification module consists of properties which we can use to verify that our implementations of  STV algorithms in HOL4 indeed match with the description of the counting methods used.  
 In light of Definition~\ref{STVMachine} these properties   actually form the semantics of the generic STV machine.   
\paragraph*{Implementation} Our final objective for creating the framework is to produce means for validating concrete evidences. To this end, we need decision procedures used for deciding whether or not a given evidence is valid. Therefore we define boolean-valued functions in the implementation sub-module to computationally realise logical declarations in the specification module. In particular, we implement decision procedures whose computational content  provably realises the specification of the machine semantics.  
\paragraph*{Verification} Here we formally prove that the implementations meet the expectations of their respective specifications. Therefore through verification we come to eliminate a trusted layer  required to lay in our framework.  


We also have another motivation for developing the auxiliary module through this three-part process of specification, implementation and then verification. Familiarity, but no expertise, with our framework and its general purpose is needed for extending it to synthesise an executable verifier for one's desired STV scheme. On the one hand, an average user may lack enough skills in grasping functional programming style which we rely on for implementing verifiers in HOL4. However, the same user most probably has had exposure to formulations of mathematical properties  in first-order logic syntax. Including purely descriptive logical assertions as our specifications, proven equivalent to their implementations, facilitates the users with means to understand the functionality of components, modules and the system as a whole simply by inspecting the specifications instead of implementations.
\subsection{Data Structure of Machine States}
\label{MachineData}
 We choose the data structure  given in Definition~\ref{judgement} for implementing the abstract data type underlying the generic STV.  We have four reasons for this choice of data structure. 
 \begin{itemize}
\item As the abstract syntactic representation of evidence closely represents concrete evidences, designing the parser and inspecting  its  correctness is less challenging.  
 \item HOL4 has well developed libraries comprised of verified assertions of operations on list structure. By structuring the data on lists, we facilitate us and users  with exploitation of  already verified tools to formalise the framework and avoid inventing the unnecessary from the scratch. 
 \item HOL4 also has well-developed tactics for discharging proof obligations on assertions involving list structure and operations on it. We therefore come to provide us with means for ease of verification of the formalised assertions.
 \item Understanding the data structure used in the  framework implementation is critical for ease of  its usability and extensibility by third parties.  The type $\mathit{judgement}$ closely models concrete evidences such as the one in figure~\ref{EvInst}. Therefore one can sensibly perceive the  abstraction step taken for modelling  concrete data which in turn enhances understandability of the framework and its mechanism. 
   \end{itemize}
\begin{definition}\label{judgement}
We formalise machine states as an inductive type  $\mathit{judgement}$ whose constructors are  $\mathit{NonFinal}$ and $\mathit{Final}$; 
\begin{holthmenv}
\HOLthm[width=60]{CheckerSpec.datatype_judgement}
\end{holthmenv}

 A $\mathit{Final~(w)}$ judgement declares $w$ as winners of the election. A  $\mathit{NonFinal~(ba,t,p,bl_{1},bl_{2},e,h)}$ judgement  consists of uncounted ballots $ba$, tally $t$, pile $p$, $bl_{1}$ the backlog of elected candidates, $bl_{2}$ the backlog of eliminated candidates, and $e$ and $h$ for the list of elected and continuing~(hopeful) candidates. The types  $\mathit{ballots}$, $\mathit{tallies}$ and $\mathit{piles}$ are respectively abbreviations for  $\mathit{((cand ~list)\times rat) list}$,   $\mathit{(cand\times rat)~list}$ and $\mathit{(cand\times(ballots~list)~list) ~list}$ where $\mathit{rat}$ is the HOL4 type of fractional numbers.
\end{definition}
 Recall that objects whose type is $\mathit{piles}$ serve as containers for recording the ballots allocated to each candidate. Our choice for type of piles allows us to store the ballots received by each candidate in chunks of lists rather than one single list containing all of them.  We have two reasons for designing the type of piles as it stands instead of $\mathit{(cand\times(ballots~list))~list}$;  
\paragraph*{(a)} Some STV schemes such as the lower house ACT and Tasmania STV, employ a nation called ''last parcel''. In short the last parcel of a candidate is the collection of those ballots received by the candidate at the last round of application of the count transition which made the tally of the candidate reach or exceed the quota and therefore be elected.  Only the last parcel, instead of all, of an elected candidate is then distributed the ballots received by the candidate. Also  they update the fractional transfer value, that each ballot in the last parcel  awaiting transfer carries, based on the length of the last parcel. To  accommodate this notion and its effect, we need identifying the ballots constituting the last parcel of an elected. We hence formalise the pile to record, for each  continuing candidate, a list consisting of lists of ballots each received upon  chronological applications of count transition.  Once a candidate is elected their pile may be manipulated differently from the continuing candidates. 
\paragraph*{(b)} We noted earlier that the STV used for the upper house elections in the Victoria state transfers votes of an eliminated candidate chunk by chunk in several applications of transfer-removed, rather than in a single action, in order of the magnitude of the fractional value that the chunks carry. We therefore need to rearrange the pile of ballots of an eliminated candidate into lists based on equality of the fractional value of ballots and then distribute them in the proper order as the scheme requires. This means that the type of piles has to be as it is defined above.   
Implementing piles in this way enables us to tailor the semantics of the transfer and elect transitions and their instantiations in such a way to modularly formalise several STV schemes which use the last parcel or stepwise distribution of votes form eliminated candidates or the combination of both. 


There is also a reason for choosing the type $rat$  
%as the underlying arithmetic for the formalisation, 
instead of e.g. floating numbers. Elections with an STV counting scheme have a small margin of victory especially for the last vacancy left to fill. This margin may happen to be less than magnitude of the error caused by accumulation of rounding errors as it is with floating points.  Therefore one must sensibly avoid paying the high  cost of electing a wrong candidate by falling into traps of imprecise calculations due to unintelligent choices. Using exact fractions allows safe  correct handling of calculations. 
\subsection{The Semantics and its Auxiliary Components}
\label{sec:MachineSem}

The semantics of each machine transition label consists of conjunctions of formally specified general pre- and post-conditions across STV schemes which enforce when and how to take a tallying action and what the immediate effect is. To demonstrate the process of specification, implementation and verification of the machine transitions and their semantics, we discuss the transfer-elect transition.


STV schemes \emph{explicitly} declare four conditions that must be satisfied  for any legitimate application of transfer-elect; 
\begin{itemize}
\item[a.] there are still vacancies to fill
\item[b.] There are no uncounted ballots to deal with
%\item[c.] no more continuing candidate other than already elected has reached or exceeded the quota
\item[c.] there is no vote from any eliminated candidate still awaiting distribution, and
\item[d.] There are surplus votes of elected candidates to  transfer.
\end{itemize}


Also there are some \emph{implicit} conditions present in legal documents describing transfer-elect. These constraints come to attention either as the result of a straightforward understanding of the explicit conditions above or as   auxiliary components that are taken for granted by legislators but are
necessary for proper functioning of the explicit constraints;
\begin{enumerate}
\item every candidate in the pre- and post-state of transfer-elected has a unique tally and pile
\item no one is elected or eliminated by applying transfer-elect
\item no candidate attracts any new vote by transfer-elect and therefore tallies remain the same
\item candidates whose names appears in the backlog of elected are indeed among elected candidates
\item any elected candidate is no longer a continuing candidate so that they do not receive votes any further
\item the list of competing candidates in the election is not empty and has no duplication of names
\end{enumerate}  
Conjunctions of formal declarations of the above explicit and implicit conditions forms the semantics of the transition label transfer-elect.   The predicate TransferAuxSpec defines  the semantics of this transition.


Transfer-elect, as is the case for other formalised transitions, is parametrised by the quota $qu$, number of initial vacancies $st$ and the list $l$ of all candidates competing in the election. The semantics of the transition declares that given the ballots $ba$, tally $t$, pile $p$, backlog of elected $bl$, backlog of eliminated $bl_{2}$ and the list of elected $e$ and continuing candidates $h$ in the pre-state of transfer-elected, and their respective counterparts in the post-state characterised by having a prime symbol, some conditions as specified above are satisfied by the transition.  
   \begin{small}
\begin{holthmenv}
  \HOLthm[def,width=63]{CheckerSpec.TransferAuxSpec_def}
\end{holthmenv}
\end{small}
   
  
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=70]{CheckerSpec.Valid_Init_CandList_def}
\end{holthmenv}
\end{small}
The predicate Valid\textunderscore{}Init\textunderscore{}CandList which realises item (6) asserts that each candidate has a pile and a tally. We also declare that elements in the first component of the tally $t$ and pile $p$ are distinct. Therefore we come to satisfy item (1).
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=60]{CheckerSpec.Valid_PileTally_def}
\end{holthmenv}
\end{small}
We implement for each of the above declarations a counterpart computational \underline{dec}ision procedure that is later translated and then extracted as part of the verifier for actual computation. To illustrate how this phase proceeds, we provide some instances. The following two functions together implement Valid\textunderscore{}PileTally.
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=60]{Checker.Valid_PileTally_dec1_def}
\end{holthmenv}
\end{small}
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=75]{Checker.Valid_PileTally_dec2_def}
\end{holthmenv}
\end{small}
We prove that the implementations and specification match:
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=60]{CheckerProof.Valid_PileTally_Spec_iff_Valid_PileTally_DEC}
\end{holthmenv}
\end{small}
Conjunctions of the computational implementations  define a computational twin TransferAuxDec for the specification  of the transfer-elect semantics TransferAuxSpec. 
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=60]{Checker.TransferAuxDec_def}
\end{holthmenv}
\end{small}

Similarly  
we obtain specification and computational implementation for other machine transitions as well. Then the specification (implementation) of the machine semantics is comprised of the collection of specification (resp. implementation) of the individual transitions. We formally prove 
%formally prove that for 
each transition implementation  matches with its specification.
\begin{theorem}
Assume $M^{spec} = \langle \mathcal{S}, \mathcal{T}, (S_{t}^{spec})_{t \in \mathcal{T}} \rangle$ is the specification of the machine and  $M^{imp} = \langle \mathcal{S}, \mathcal{T}, (S_{t}^{dec})_{t \in \mathcal{T}} \rangle$ is its computational implementation. Then for any $t\in\mathcal{T}$,  $\mathcal{S}_{t}^{spec}\Leftrightarrow\mathcal{S}_{t}^{dec}$.      
\end{theorem}

One can already proceed to synthesise an executable verifier from the machine. Such a verifier can correctly decide if given evidence $\omega$ claimed to have been produced by an algorithm whose counting scheme is STV, instead of e.g. PR list schemes or FPTP.  
However we wish to generate verifiers that can recognise and validate according to which specific STV algorithm the evidence $\omega$ has been output. Hence we need to enrich the computational content of the machine semantics with more  pre- and post-conditions which are particular to individual STV schemes. We refer to this enrichment process as instantiation of the machine and discuss it further below.
\section{Instantiations of the Machine}\label{sec:InstMachine}
We exemplify how instantiation of the transfer-elected succeeds for transferring surplus of elected candidates based on the ACT STV
\footnote{The Tasmania STV also uses similar surplus transfer mechanism.}. Instantiation of other machine transitions proceed in a  similar manner.    
Under section 'Step 3' and 'transfer surplus from elected candidates' the protocol explains under what conditions and how to distribute surplus votes. We summarise and rephrase these sections as follows. 
\begin{itemize}
\item[$\bullet_{1}$] no  candidate exceeds the quota
%\item[$\bullet_{2}$] ballots received by a candidate are piled in separate chunks called parcels. 
\item[$\bullet_{2}$] the  parcel of an elected with surplus is not empty.
\item[$\bullet_{3}$] distribution of the surplus of an elected candidate proceeds in one single step.
\item[$\bullet_{4}$] surplus of elected candidates is distributed one at a time beginning with those who are elected earlier. 
\item[$\bullet_{5}$] pile of the candidate whose surplus is transferred is emptied in the post-state of transfer-elect.
\item[$\bullet_{6}$] only the last parcel of votes  received (which resulted in a surplus) is transferred. It may be that the last parcel is the only parcel in a candidate's pile (if only one application of the count action has occurred), or more parcels exist (if several actions of count has happened as a result of earlier  elect, transfer or eliminate actions)
\item[$\bullet_{7}$] pile of any candidate other than the one whose surplus is transferred at this stage remains the same.
\item[$\bullet_{8}$] the fractional transfer value is subsequently computed depending on whether or not the last parcel is the only parcel of ballots in the pile of the elected candidate. 
\end{itemize}
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=65]{Checker.TransferActSpec_def}
\end{holthmenv}
\end{small}
We augment the formal counterparts of the $\bullet_{i}$ conditions  to the clauses given in section~\ref{sec:MachineSem} to obtain the specification TransferActSpec for transfer-elect of ACT STV.  The last conjunct of TransferActSpec asserts that the pile of every candidate other than $c$ remains the same in both pre- and post-state of the transition. Also note that we place the last parcel of the pile of the candidate $c$ whose votes are transferred first into the list of uncounted ballots so that in the subsequent transition count deals with distributing the votes and "recalculating" candidates' tallies and piles. Finally, because of efficiency purposes our system is designed to update the fractional transfer value of the surplus in formalisation of the elect transition instead of transfer-elect. 

We next define computational twins for the components of TransferActSpec and use them to implement a computational counterpart for the semantics of the ACT transfer-elect. 
For example, the function  get\textunderscore{}cand\textunderscore{}tally looks through a tally list $t$ and finds the tally of an input candidate name $c$. We then verify this function  computes the tally of candidates correctly and that indeed every candidate is assigned only one tally (item 1 of the implicit machine conditions).
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=60]{CheckerProof.EVERY_CAND_HAS_ONE_TALLY}
\end{holthmenv}
\end{small}
Using this function, we implement another function less\textunderscore{}than\textunderscore{}quota which checks if the tally of every candidate in a given list $ls$ is below the quota (item $\bullet_{1}$).
\begin{small}
\begin{holthmenv}
 \HOLthm[def,width=60]{Checker.less_than_quota_def}
\end{holthmenv}
\end{small} 
We show less\textunderscore{}than\textunderscore{}quota is a  computational realisation of  its specification: 
\begin{small}
\begin{holthmenv}
  \HOLthm[def,width=70]{CheckerProof.LogicalLessThanQu_IMP_less_than_quota}
\end{holthmenv}
\end{small}
Moreover less\textunderscore{}than\textunderscore{}quota enforces its specification.
 \begin{small}
\begin{holthmenv}
  \HOLthm[def,width=70]{CheckerProof.less_than_qu_IMP_LogicalLessThanQuota}
\end{holthmenv}
\end{small}
 In the same manner we define and verify other functions that computationally  implement the rest of components of the transfer-elect specification. Conjunctions of the implementations constitute a computational semantics for transfer-elect. 
 \begin{small}
 \begin{holthmenv}
  \HOLthm[def,width=70]{Checker.TransferActDec_def}
\end{holthmenv}
\end{small}
We next demonstrate how the framework modularly extends to instantiations  with various STV algorithms.
\subsection{Variations in Instantiation}
We discuss instantiation of the transfer-elect  based on the Victoria and CADE STV. As we have already illustrated how a specification and the corresponding implementation of an algorithm advance, we therefore only elaborate on how they vary from ACT STV in textual descriptions of their semantics and subsequently their implementations. 
\subsubsection{Victoria STV}
Legislature of Victoria's counting scheme does not strictly speak about the notion of parcel. However, as explained under the subsection~\ref{MachineData} it transfers votes of an eliminated candidate stepwise which therefore requires separating votes into different chunks (or parcels). Having eliminated possible misunderstanding, note that Victoria STV matches with ACT STV  on every $\bullet_{i}$ item except for $i\in\{6,8\}$.

\begin{itemize}
\item[$\bullet_{6'}$] transfer all of the surplus votes of an elected candidate at a reduced fraction.
\item[$\bullet_{8'}$] the fractional transfer value is computed based on all of the surplus (not necessarily depending on the last parcel).
\end{itemize} 

Note that we deal with updating fractional transfer value in the semantics of elect transitions. Also in instantiations of the elect semantics, we guarantee elements of the backlog of elected candidates ($bl_{1}$) are all above the quota. Therefore we formalise Victoria's transfer-elect semantics as follows.
\begin{small}
 \begin{holthmenv}
  \HOLthm[def,width=70]{Checker.TransferVicDec_def}
\end{holthmenv}
\end{small}
\subsubsection{CADE STV}
This scheme is radically different than ``standard'' STV algorithms. In particular, to the best of our knowledge, every ``normal'' STV algorithm at least respects $\bullet_{1}$. However CADE violates not only this condition but also all of the ACT's transfer-elect semantics components except $\bullet_{2}$. This unorthodox behaviour of CADE permeates to the semantics of other transitions as well to an extent where the algorithm is sometimes questioned to be a true member  of the STV family. But our framework flexibly  accommodates even the extraordinary ones. We catalogue CADE's transfer-elect informal semantics  conditions as follows.
\begin{itemize}
\item[$\star_{1}$] the backlog of  elected candidates contains one element.
\item[$\star_{2}$] parcel of the element in the backlog of elected candidates is not empty.
\item[$\star_{3}$] backlog of the elected candidates is emptied in the post-state of transfer-elect.
\item[$\star_{4}$] the election \underline{restarts} after each round of transfer-elect.
\end{itemize}  
The clause $\star_{4}$ itself consists of the following sub-clauses.
\begin{itemize}
\item[$\star_{4a}$] pile of \underline{all of the candidates} is emptied in the post-state.
\item[$\star_{4b}$] all ballots in the piles of \underline{all candidates} are placed back into the list of uncounted ballots with the name of already elected candidate removed from those ballots.
\item[$\star_{4c}$] the eliminated candidates are ``resurrected'' meaning they start to be continuing candidates in the post-state.  
 %\subsection{Instantiation with an Arbitrary STV Algorithm}
\end{itemize}
\begin{small}
 \begin{holthmenv}
  \HOLthm[def,width=70]{Checker.TransferCadeDec_def}
\end{holthmenv}
\end{small}
\begin{remark}\label{naming}
In this section, when we instantiated transitions of the machine, particularly transfer-elect, we named instantiations differently. For example, we represented instantiation of transfer-elect with the Victoria STV by  Transfer\underline{Vic}Dec. This choice was out of pedagogical purposes to assist the reader with understanding the work. In actual engineering however we practice a sensible alternative. We carry out different instantiations of the machine in separate modules but uniformly name instantiations of the transitions. For example, for instantiation of the machine with the Victoria STV, we have a module accordingly named and inside the module we refer, for instance, to instantiation of transfer-elect as TransferDec or TransferSpec without the infix Vic.
\end{remark}
\begin{remark}\label{rewrting}
The Core calculus of HOL4 uses \emph{term rewriting} to manipulate assertions expressed in higher-order logic and ML programming style.   
Since HOL4 is a rewriting system, what appears as the name of an assertion on the left of $\Leftrightarrow$ is therefore secondary to its definitional content on the right side. In light of the previous remark, we can uniformly refer to \emph{names} of instantiated transitions regardless of the algorithm used. Therefore we can formulate evidence verifier based on the names of the transitions but call in the desired instantiation  module to embody the names with the semantics  of the algorithm intended to obtain a verifier for. Consequently the verifier, translation, deepSpec and compilation modules which all depend on instantiation modules as their parents  are    developed once and for all.   
\end{remark}

 
\subsection{Automating Verification of Instantiations}  
Once an instantiation of the machine  completes   
 we next proceed to verify logical equivalences of the specification of each transition as a unity with its  implementation. 
Based on our experience, proving  such equivalence  
roughly requires 200 lines of HOL4 encoding. 
We desire to automate them in a way that they practically approximate the following desideratum.    
 \begin{conjecture}\label{conj}
 Assume $\mathcal{A}$ is an \underline{arbitrary} STV algorithm, $\hat{\mathcal{A}}_{spec}= \langle \mathcal{S}, \mathcal{T}, (S_{t}^{spec})_{t \in \mathcal{T}} \rangle$ is a specification of $\mathcal{A}$'s instantiation into the machine and $\hat{\mathcal{A}}_{dec}= \langle \mathcal{S}, \mathcal{T}, (S_{t}^{dec})_{t \in \mathcal{T}} \rangle$ is its implementation. 
  Then for any $t\in\mathcal{T}$ the framework \underline{automatically} proves  $\mathcal{S}_{t}^{dec}\Leftrightarrow\mathcal{S}_{t}^{spec}$. 
 \end{conjecture}
We engineer the framework in a way that the proofs module calls instantiation modules as its parents  one by one.
 Considering Remark~\ref{naming},   we uniformly declare the desired equivalence between the specification and implementation of an instantiated transition and discharge the proof in the proofs module.


Engineered this way, the desideratum is met under the following two scenarios for the proofs module. However for a third scenario, proofs in the module may break so that proving the equivalences  becomes a semi-automatic interactive procedure. The proofs nonetheless remain reusable after proper refinements so that one needs not re-encoding 200 lines.  
 \paragraph*{Scenario one} We have already formalised and verified instantiation of the machine with five different STV algorithms. If the algorithm $\mathcal{A}$ already exists in our framework then the desideratum is satisfied. No effort beyond following simple instructions to execute on the command line is required to synthesise an executable verifier.  
 \paragraph*{Scenario two} Another possibility is that 
 %the algorithm intended to be instantiated into the machine 
 $\mathcal{A}$ as a whole does not literally match with any of the already existing instantiations of the machine. However, clauses describing pre- and post-conditions of transitions which are components of the semantics of $\mathcal{A}$ do exist in the auxiliary module. Then all one needs doing is to call the formal  specifications of the clauses and their respective implementations into the specification and implementation of transitions, respectively,  to formally obtain an instantiation of the algorithm. In this case, the proofs also succeed in satisfying the conjecture. 
 \paragraph*{Scenario three} 
  
 Suppose there is a clause in description of $\mathcal{A}$ whose specification, and  therefore implementation,  does not exist in the auxiliary module. Then one trivially has to extend the auxiliary module by specifying and implementing that clause and then verifying the implementation correct against the specification.  If one was overconfident in their implementation, then they can take the implementation as its specification in which case there no verification is required.  Note that as including the generic formal machine transitions in the semantics of each transition instantiation is mandatory  
 there are few  numbers of such clauses and consequently few lines of encoding needed to formalise them. 
 
 Once the proofs of equivalence between the specification and implementation of a machine instantiation either automatically or interactively succeed, the rest of verifier synthesis process for the instantiated algorithm completely automatically follows to eventually obtain an executable verifier. 
\section{Modular Synthesis of Verifiers}\label{sec:Syn}

According to Definition~\ref{verifier} the notion of verifier depends on instantiation of the machine with an algorithm $\mathcal{A}$. In light of Remark~\ref{naming}, we only need to develop the verifier module once and simply vary the parent instantiation module to adapt the definition of the verifier for a different instantiation. So let's assume $\hat{\mathcal{A}}_{spec}= \langle \mathcal{S}, \mathcal{T}, (S_{t}^{spec})_{t \in \mathcal{T}} \rangle$ and $\hat{\mathcal{A}}_{dec}= \langle \mathcal{S}, \mathcal{T}, (S_{t}^{dec})_{t \in \mathcal{T}} \rangle$ are the specification and implementation of an STV algorithm $\mathcal{A}$ where for any $t\in\mathcal{T}$, $\mathcal{S}_{t}^{dec}\Leftrightarrow\mathcal{S}_{t}^{spec}$. 
 Then we define $\mathcal{V}_{spec}$ as the specification of the verifier  and implement $\mathcal{V}_{dec}$ as its  computational counterpart. Drawing on proofs established between $\mathcal{S}_{t}^{dec}$ and $\mathcal{S}_{t}^{spec}$ for the transitions, we formally prove the following result.
\begin{theorem} 
 Suppose the algorithm $\mathcal{A}$ is instantiated in the machine as above. Then for any piece of evidence $\hat{\omega}= (Q,s,C,\Omega)$ produced by an execution of $\mathcal{A}_{dec}$, $\mathcal{V}_{spec}~(Q,s,C)~ \Omega\Leftrightarrow\mathcal{V}_{dec}~(Q,s,C)~\Omega$.    
\end{theorem}
As the specification and implementation are equivalent, we shall only discuss the formalisation of the implementation. We first define the decision procedure Valid\textunderscore{}Step which for given two machine states $j_{0}$ and $j_{1}$ decides if a transition from the former to the latter occurs by an application of a transition.
\begin{small}
 \begin{holthmenv}
  \HOLthm[def,width=60]{Checker.Valid_Step_def}
\end{holthmenv}
\end{small}
Then we implement the function valid\textunderscore{}judgements\textunderscore{}dec which recursively calls Valid\textunderscore{}Step on a list of machine states.
\begin{small}
 \begin{holthmenv}
  \HOLthm[def,width=60]{Checker.valid_judgements_dec_def}
\end{holthmenv}
\end{small} 
The verifier in HOL4 is eventually defined a follows where the function initial\textunderscore{}Judgement\textunderscore{}dec decides if the first element of a piece of evidence is a machine state correctly recording information of the initial state of tallying votes where no one has yet attracted any vote, the backlogs of elected and eliminated and the list of elected are all empty and every candidate is continuing. 
\begin{small}
 \begin{holthmenv}
  \HOLthm[def,width=65]{Checker.Check_Parsed_Certificate_def}
\end{holthmenv}
\end{small} 
One can use Check\textunderscore{}Parsed\textunderscore{}Certificate to run small sample elections manually encoded in HOL4's environment. However real evidence such as figure~\ref{EvInst} are stored in a file in an operating system which need to be read, parsed, and processed for validation. Therefore we need an executable verifier in an operating system's environment. On the other hand, Check\textunderscore{}Parsed\textunderscore{}Certificate despite its infeasibility for computation, is proven to behave correctly as the specification $\mathcal{V}_{spec}$ expects. How can we synthesise from it an executable verifier $\mathcal{V}$ that is both efficient for actual computation and provably correct with respect to $\mathcal{V}_{spec}$ and thus trustworthy? To this end, we invoke the verified CakeML's proof translator tool, its ecosystem and the compiler.

Using the verified CakeML's translator we obtain a translated version of the verifier $\mathcal{V}_{\tau}$. Thanks to the translator, we are guaranteed that every property proven for  
 Check\textunderscore{}Parsed\textunderscore{}Certificate and its components also holds for $\mathcal{V}_{\tau}$ and its components. Therefore correctness of the verifier in HOL4 provably extends to that of $\mathcal{V}_{\tau}$. The translated verifier $\mathcal{V}_{\tau}$ is a pure function operating in CakeML's environment. To synthesise an executable verifier that actually opens files, parses evidence lines and validates them according to $\mathcal{V}_{spec}$, we implement a deeply embedded function called check\textunderscore{}count in CakeML's ecosystem.  CakeML has  libraries developed for modelling and verifying properties about I/O semantics of the executable versions  of a deeply embedded impure function.  Using this modelling we specify and prove that the specified and \underline{compiled} check\textunderscore{}count behaves as follows. 
 
 The function check\textunderscore{}count accepts a file as input on the command line, opens the file consisting of  evidence which we intend to validate, parses the header of the evidence consisting of the quota, number of seats and competing candidates in the election. If the header is well-formed, then check\textunderscore{}count proceeds to parse two judgement lines at a time and if the lines  successfully parse into  values of the type judgement (the type of the machine states) then checks if  the transition happening between them \emph{corresponds with the specification of the verifier in HOL4 ($\mathcal{V}_{spec}$)}. This process of reading evidence lines, parsing and checking them continues until either the evidence is accepted as valid or  check\textunderscore{}count encounters a malformed judgement line or an invalid transition step from one parsed judgement (machine state) to another  in which case it returns an error messages  informing us where it occurs.  
 
\section{Experimental Results}

Figure~\ref{ParamACT} illustrates the lower house election electorates of the ACT state of Australia with the size of their respective input valid ballots and parameters (seats and candidates) for the elections held in years 2008 and 2012. Figure~\ref{EvACT} shows some of the experimental results performed on real historical data of these districts. For each election, we obtain evidence  by executing a Haskell program\footnote{Source code at \url{https://github.com/MiladKetabGhale/Modular_Checker}} computing winners of each election  according to ACT STV. Then the verifier synthesised for validating instances of computation with the ACT STV verifies each evidence as valid\footnote{Using one processor of an Intel Core i7-7500U CPU\@ 2.70 GHz$\times$4}. Note that certifying evidence  validity is costlier than detecting the invalidity of evidence of the same size, because for the former  \emph{every}  transition has to be verified while the latter  is detected before the verifier processes the whole evidence. 
\begin{figure}[t]
\centering
\begin{small}
\begin{tabular}{|c | c | c | c | c|}
\hline
Electorate&Ballots&Candidates&Seats&year\\
\hline
Brindabella&63562&20&5&2012\\
\hline
Ginnindra&66076&27&5&2012\\
\hline
Molonglo&88266&40&7&2008\\
\hline
\end{tabular}
\end{small} 
\caption{Parameters of the ACT Lower house elections 2008/2012} 
\label{ParamACT}
\end{figure}
\begin{figure}[h]
\centering
\begin{small}
\begin{tabular}{|c | c | c | c | c|}
\hline
Electorate&Evidence size (mb)&Validation time (sec)&year\\
\hline
Brindabella&57.5&1627&2012\\
\hline
Ginnindra&72.7&1789&2012\\
\hline
Molonglo&195.6&12063&2008\\
\hline
\end{tabular}
\end{small} 
\caption{Evidence Validation for the ACT Lower house elections 2008/2012}
\label{EvACT} 
\end{figure}


Contrary to the folklore that theorem provers are basically meant for verification, rather than efficient computation, the generated verifier for ACT STV performs great. For example, Molonglo electorate is the biggest electoral district among the lower elections in terms of the constituency magnitude and vacancies. Despite  costly computation carried out to meticulously examine correctness of every small detail in the evidence, the verifier validates it in about three hours. Considering the typical time lapse in publicly announcing real election results, this performance is reasonably outstanding.  


%We have implemented a Haskell program computing winners of input ballots Molonglo is the biggest electorate of the lower house elections in Australia both in terms of constituency and size (number of vacancies). 

\section{Related Work}
\section{Conclusion}



%\bibliographystyle{splncs03}
%\bibliography{paper,delta2,ev}
\end{document}
% vim: ft=tex
